---
alwaysApply: true
description: Clean modular architecture patterns for Python data processing
---

# Clean Modular Architecture Patterns

Follow the design principles demonstrated in [gps_preprocessor.py](mdc:gps_preprocessor.py):

## File Organization Structure
```python
# 1. Configuration & Constants (40-80 lines)
@dataclass
class Config:
    """Centralized configuration with defaults"""

class Schema:
    """Data schema and column definitions"""

# 2. Utility Functions (20-40 lines) 
def utility_function():
    """Reusable, stateless functions"""

# 3. Specialized Classes (60-120 lines each)
class DataLoader:
    """Single responsibility: data loading"""

class DataCleaner: 
    """Single responsibility: data cleaning"""

# 4. Pipeline Orchestrator (80-100 lines)
class MainProcessor:
    """Coordinates all components"""

# 5. Main Entry Point (50 lines)
def main():
    """CLI and execution logic"""
```

## SOLID Principles
- **Single Responsibility**: Each class has ONE clear purpose
- **Atomic Methods**: Break large methods (>30 lines) into focused sub-methods
- **Clear Naming**: Methods should describe exactly what they do
- **Dependency Injection**: Pass dependencies through constructors

## Method Design Patterns
```python
# PUBLIC methods: Main functionality
def process_data(self) -> Result:
    """Public interface with clear return types"""

# PRIVATE methods: Implementation details  
def _prepare_data(self) -> ProcessedData:
    """Single-purpose helper methods"""
    
def _validate_input(self) -> bool:
    """Focused validation logic"""
    
def _report_results(self) -> None:
    """Logging and reporting"""
```

## Error Handling
- Fail fast with informative error messages
- Use try/except blocks with specific exception types
- Always include context in error messages
- Return structured results instead of raising exceptions when possible